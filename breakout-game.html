<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dual Ball Breakout</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        
        #gameCanvas {
            border: 2px solid #333;
            background-color: #ddd;
            margin: 20px 0;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        #startBtn {
            background-color: #4CAF50;
            color: white;
        }
        
        #startBtn:hover {
            background-color: #45a049;
        }
        
        #pauseBtn {
            background-color: #ff9800;
            color: white;
        }
        
        #pauseBtn:hover {
            background-color: #e68900;
        }
        
        #resetBtn {
            background-color: #f44336;
            color: white;
        }
        
        #resetBtn:hover {
            background-color: #da190b;
        }
        
        .score {
            display: flex;
            gap: 40px;
            font-size: 18px;
            font-weight: bold;
        }
        
        .score-item {
            text-align: center;
        }
        
        .light-score {
            color: #333;
        }
        
        .dark-score {
            color: #666;
        }
    </style>
</head>
<body>
    <h1>Dual Ball Breakout</h1>
    
    <div class="controls">
        <button id="startBtn">Spiel starten</button>
        <button id="pauseBtn">Pause</button>
        <button id="resetBtn">Reset</button>
    </div>
    
    <canvas id="gameCanvas" width="1024" height="1024"></canvas>
      <div class="score">
        <div class="score-item light-score">
            <div>Helle Felder</div>
            <div id="lightFields">512</div>
        </div>
        <div class="score-item dark-score">
            <div>Dunkle Felder</div>
            <div id="darkFields">512</div>
        </div>
    </div>

    <script>
        // Canvas und Kontext
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
          // Spielkonstanten
        const CANVAS_WIDTH = 1024;
        const CANVAS_HEIGHT = 1024;
        const FIELD_SIZE = 32; // 16x16 Pixel pro Feld
        const FIELDS_X = 32; // 32 Felder horizontal
        const FIELDS_Y = 32; // 32 Felder vertikal
        const BALL_RADIUS = 6;
        const BALL_SPEED = 2;
          // Spielzustand
        let gameRunning = false;
        let animationId = null;
        
        // Audio Context für Soundeffekte
        let audioContext = null;
          // Partikeleffekte
        let particles = [];
        
        // Spielfeld - 0 = helles Feld, 1 = dunkles Feld
        let gameField = [];
        
        // Animierte Felder für Dreheffekt
        let animatedFields = [];
          // Bälle
        let lightBall = {
            x: CANVAS_WIDTH * 0.75, // Startet auf der dunklen Seite
            y: CANVAS_HEIGHT / 2,
            dx: -BALL_SPEED,
            dy: BALL_SPEED,
            color: '#ffffff',
            trail: [] // Schweif-Positionen
        };
        
        let darkBall = {
            x: CANVAS_WIDTH * 0.25, // Startet auf der hellen Seite
            y: CANVAS_HEIGHT / 2,
            dx: BALL_SPEED,
            dy: -BALL_SPEED,
            color: '#000000',
            trail: [] // Schweif-Positionen
        };
        
        // Audio Context initialisieren
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        
        // Soundeffekt abspielen
        function playConversionSound(isLightBall) {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Verschiedene Töne für helle und dunkle Bälle
            if (isLightBall) {
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
            } else {
                oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.1);
            }
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.1);
        }
          // Partikel für Feldumwandlung erstellen
        function createConversionParticles(x, y, fromColor, toColor) {
            const centerX = x * FIELD_SIZE + FIELD_SIZE / 2;
            const centerY = y * FIELD_SIZE + FIELD_SIZE / 2;
            
            // 8 Partikel pro Umwandlung
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const speed = 2 + Math.random() * 3;
                  const maxLife = 30 + Math.random() * 20;
                particles.push({
                    x: centerX,
                    y: centerY,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: maxLife,
                    maxLife: maxLife,
                    fromColor: fromColor,
                    toColor: toColor,
                    size: 2 + Math.random() * 2
                });
            }
        }
          // Animierte Feldumwandlung erstellen
        function createFieldAnimation(x, y, fromColor, toColor) {
            // Bestehende Animation für dieses Feld entfernen
            animatedFields = animatedFields.filter(field => !(field.x === x && field.y === y));
            
            // Neue Animation hinzufügen
            animatedFields.push({
                x: x,
                y: y,
                fromColor: fromColor,
                toColor: toColor,
                rotation: 0,
                maxRotation: Math.PI, // 180 Grad Drehung
                duration: 40, // 40 Frames = 0.67 Sekunden bei 60fps (etwas länger für besseren Effekt)
                currentFrame: 0
            });
        }
          // Partikel updaten und zeichnen
        function updateAndDrawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                // Partikel bewegen
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                
                // Partikel entfernen wenn abgelaufen
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                    continue;
                }
                
                // Partikel zeichnen mit Farbübergang
                const progress = 1 - (particle.life / particle.maxLife);
                const alpha = Math.max(0, 1 - progress);
                
                ctx.save();
                ctx.globalAlpha = alpha;
                
                // Farbübergang von alter zu neuer Farbe
                if (particle.fromColor === 0) {
                    // Von weiß zu schwarz
                    const grayValue = Math.floor(255 * (1 - progress));
                    ctx.fillStyle = `rgb(${grayValue}, ${grayValue}, ${grayValue})`;
                } else {
                    // Von schwarz zu weiß
                    const grayValue = Math.floor(255 * progress);
                    ctx.fillStyle = `rgb(${grayValue}, ${grayValue}, ${grayValue})`;
                }
                
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size * alpha, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        // Animierte Felder updaten und zeichnen
        function updateAndDrawAnimatedFields() {
            for (let i = animatedFields.length - 1; i >= 0; i--) {
                const field = animatedFields[i];
                
                // Animation updaten
                field.currentFrame++;
                const progress = field.currentFrame / field.duration;
                field.rotation = progress * field.maxRotation;
                
                // Animation entfernen wenn fertig
                if (field.currentFrame >= field.duration) {
                    animatedFields.splice(i, 1);
                    continue;
                }
                
                // Feld mit Dreheffekt zeichnen
                drawRotatingField(field, progress);
            }
        }
          // Rotierendes Feld zeichnen
        function drawRotatingField(field, progress) {
            const fieldX = field.x * FIELD_SIZE;
            const fieldY = field.y * FIELD_SIZE;
            const centerX = fieldX + FIELD_SIZE / 2;
            const centerY = fieldY + FIELD_SIZE / 2;
            
            ctx.save();
            ctx.translate(centerX, centerY);
            
            // Vertikale Drehung um die horizontale Achse (X-Achse)
            // Skalierung der Y-Achse für 3D-Flip-Effekt von unten nach oben
            const scaleY = Math.cos(progress * Math.PI);
            
            // Während der ersten Hälfte der Animation zeigen wir die alte Farbe
            // Während der zweiten Hälfte zeigen wir die neue Farbe
            let currentColor;
            if (progress < 0.5) {
                // Erste Hälfte: Alte Farbe (von unten sichtbar)
                currentColor = field.fromColor === 0 ? '#ffffff' : '#000000';
                ctx.scale(1, Math.abs(scaleY));
            } else {
                // Zweite Hälfte: Neue Farbe (von oben sichtbar)
                currentColor = field.toColor === 0 ? '#ffffff' : '#000000';
                // Umkehrung der Skalierung für die "Rückseite"
                ctx.scale(1, Math.abs(scaleY));
            }
            
            // Feld zeichnen
            ctx.fillStyle = currentColor;
            ctx.fillRect(-FIELD_SIZE / 2, -FIELD_SIZE / 2, FIELD_SIZE, FIELD_SIZE);
            
            // Zusätzlicher visueller Effekt: Schatten/Gradient für mehr 3D-Gefühl
            if (Math.abs(scaleY) < 0.3) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(-FIELD_SIZE / 2, -FIELD_SIZE / 2, FIELD_SIZE, FIELD_SIZE);
            }
            
            ctx.restore();
        }
        function initGameField() {
            gameField = [];
            for (let y = 0; y < FIELDS_Y; y++) {
                gameField[y] = [];
                for (let x = 0; x < FIELDS_X; x++) {
                    // Linke Hälfte = helle Felder (0), rechte Hälfte = dunkle Felder (1)
                    gameField[y][x] = x < FIELDS_X / 2 ? 0 : 1;
                }
            }
            updateFieldCounts();
        }
        
        // Feldanzahl aktualisieren
        function updateFieldCounts() {
            let lightCount = 0;
            let darkCount = 0;
            
            for (let y = 0; y < FIELDS_Y; y++) {
                for (let x = 0; x < FIELDS_X; x++) {
                    if (gameField[y][x] === 0) lightCount++;
                    else darkCount++;
                }
            }
            
            document.getElementById('lightFields').textContent = lightCount;
            document.getElementById('darkFields').textContent = darkCount;
        }
          // Spielfeld zeichnen
        function drawGameField() {
            for (let y = 0; y < FIELDS_Y; y++) {
                for (let x = 0; x < FIELDS_X; x++) {
                    // Überprüfen ob dieses Feld gerade animiert wird
                    const isAnimated = animatedFields.some(field => field.x === x && field.y === y);
                    
                    // Nur statische Felder zeichnen (animierte werden separat gezeichnet)
                    if (!isAnimated) {
                        const fieldX = x * FIELD_SIZE;
                        const fieldY = y * FIELD_SIZE;
                        
                        if (gameField[y][x] === 0) {
                            ctx.fillStyle = '#ffffff'; // Helles Feld
                        } else {
                            ctx.fillStyle = '#000000'; // Dunkles Feld
                        }
                        
                        ctx.fillRect(fieldX, fieldY, FIELD_SIZE, FIELD_SIZE);
                    }
                }
            }
        }
          // Ball zeichnen
        function drawBall(ball) {
            // Schweif zeichnen
            for (let i = 0; i < ball.trail.length; i++) {
                const pos = ball.trail[i];
                const alpha = (i + 1) / ball.trail.length * 0.8; // Transparenz wird schwächer
                const radius = BALL_RADIUS * alpha; // Radius wird kleiner
                
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
                
                if (ball.color === '#ffffff') {
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                } else {
                    ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
                }
                
                ctx.fill();
            }
            
            // Ball selbst zeichnen
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, 2 * Math.PI);
            ctx.fillStyle = ball.color;
            ctx.fill();
            ctx.strokeStyle = ball.color === '#ffffff' ? '#000000' : '#ffffff';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
        
        // Kollision mit Wänden prüfen
        function checkWallCollision(ball) {
            // Linke und rechte Wand
            if (ball.x - BALL_RADIUS <= 0 || ball.x + BALL_RADIUS >= CANVAS_WIDTH) {
                ball.dx = -ball.dx;
                ball.x = Math.max(BALL_RADIUS, Math.min(CANVAS_WIDTH - BALL_RADIUS, ball.x));
            }
            
            // Obere und untere Wand
            if (ball.y - BALL_RADIUS <= 0 || ball.y + BALL_RADIUS >= CANVAS_HEIGHT) {
                ball.dy = -ball.dy;
                ball.y = Math.max(BALL_RADIUS, Math.min(CANVAS_HEIGHT - BALL_RADIUS, ball.y));
            }
        }        // Kollision mit Feldern prüfen
        function checkFieldCollision(ball) {
            const ballLeft = ball.x - BALL_RADIUS;
            const ballRight = ball.x + BALL_RADIUS;
            const ballTop = ball.y - BALL_RADIUS;
            const ballBottom = ball.y + BALL_RADIUS;
            
            // Betroffene Felder ermitteln
            const leftField = Math.floor(ballLeft / FIELD_SIZE);
            const rightField = Math.floor(ballRight / FIELD_SIZE);
            const topField = Math.floor(ballTop / FIELD_SIZE);
            const bottomField = Math.floor(ballBottom / FIELD_SIZE);
            
            let collisionX = false;
            let collisionY = false;
            
            for (let y = Math.max(0, topField); y <= Math.min(FIELDS_Y - 1, bottomField); y++) {
                for (let x = Math.max(0, leftField); x <= Math.min(FIELDS_X - 1, rightField); x++) {
                    const fieldType = gameField[y][x];
                    const ballIsLight = ball.color === '#ffffff';
                    
                    // Kollisionsrichtung bestimmen
                    const fieldCenterX = x * FIELD_SIZE + FIELD_SIZE / 2;
                    const fieldCenterY = y * FIELD_SIZE + FIELD_SIZE / 2;
                    
                    const deltaX = ball.x - fieldCenterX;
                    const deltaY = ball.y - fieldCenterY;
                      // RICHTIGE LOGIK:
                    // Heller Ball (weiß): wandelt helle Felder (0) in dunkle um, kann über dunkle Felder (1) fahren
                    // Dunkler Ball (schwarz): wandelt dunkle Felder (1) in helle um, kann über helle Felder (0) fahren
                    
                    if (ballIsLight) {
                        // Heller Ball
                        if (fieldType === 0) {
                            // Helles Feld umwandeln
                            gameField[y][x] = 1;
                            
                            // Effekte hinzufügen
                            playConversionSound(true);
                            createConversionParticles(x, y, 0, 1);
                            createFieldAnimation(x, y, 0, 1);
                            
                            // Ball prallt ab
                            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                                collisionX = true;
                            } else {
                                collisionY = true;
                            }
                        }
                        // Bei dunklen Feldern (fieldType === 1) passiert nichts - Ball kann darüber fahren
                    } else {
                        // Dunkler Ball
                        if (fieldType === 1) {
                            // Dunkles Feld umwandeln
                            gameField[y][x] = 0;
                            
                            // Effekte hinzufügen
                            playConversionSound(false);
                            createConversionParticles(x, y, 1, 0);
                            createFieldAnimation(x, y, 1, 0);
                            
                            // Ball prallt ab
                            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                                collisionX = true;
                            } else {
                                collisionY = true;
                            }
                        }
                        // Bei hellen Feldern (fieldType === 0) passiert nichts - Ball kann darüber fahren
                    }
                }
            }
            
            // Ballrichtung ändern bei Kollision
            if (collisionX) ball.dx = -ball.dx;
            if (collisionY) ball.dy = -ball.dy;
            
            return collisionX || collisionY;
        }        // Ball bewegen
        function moveBall(ball) {
            // Aktuelle Position zum Schweif hinzufügen
            ball.trail.push({x: ball.x, y: ball.y});
            
            // Schweif auf maximale Länge begrenzen
            const maxTrailLength = 16;
            if (ball.trail.length > maxTrailLength) {
                ball.trail.shift(); // Älteste Position entfernen
            }
            
            ball.x += ball.dx;
            ball.y += ball.dy;
            
            // Kollisionen prüfen
            checkWallCollision(ball);
            if (checkFieldCollision(ball)) {
                updateFieldCounts();
            }
        }          // Spiel rendern
        function render() {
            // Canvas leeren
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Spielfeld zeichnen
            drawGameField();
            
            // Animierte Felder zeichnen
            updateAndDrawAnimatedFields();
            
            // Partikeleffekte zeichnen
            updateAndDrawParticles();
            
            // Bälle zeichnen
            drawBall(lightBall);
            drawBall(darkBall);
        }
        
        // Game Loop
        function gameLoop() {
            if (!gameRunning) return;
            
            // Bälle bewegen
            moveBall(lightBall);
            moveBall(darkBall);
            
            // Rendern
            render();
            
            // Nächster Frame
            animationId = requestAnimationFrame(gameLoop);
        }
          // Spiel starten
        function startGame() {
            initAudio(); // Audio initialisieren
            gameRunning = true;
            gameLoop();
        }
        
        // Spiel pausieren
        function pauseGame() {
            gameRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }
        
        // Spiel zurücksetzen
        function resetGame() {
            pauseGame();            // Spielfeld zurücksetzen
            initGameField();
            
            // Partikel zurücksetzen
            particles = [];
            
            // Animierte Felder zurücksetzen
            animatedFields = [];
              // Bälle zurücksetzen
            lightBall.x = CANVAS_WIDTH * 0.75;
            lightBall.y = CANVAS_HEIGHT / 2;
            lightBall.dx = -BALL_SPEED;
            lightBall.dy = BALL_SPEED;
            lightBall.trail = []; // Schweif zurücksetzen
            
            darkBall.x = CANVAS_WIDTH * 0.25;
            darkBall.y = CANVAS_HEIGHT / 2;
            darkBall.dx = BALL_SPEED;
            darkBall.dy = -BALL_SPEED;
            darkBall.trail = []; // Schweif zurücksetzen
            
            // Rendern
            render();
        }
        
        // Event Listener
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('pauseBtn').addEventListener('click', pauseGame);
        document.getElementById('resetBtn').addEventListener('click', resetGame);
        
        // Spiel initialisieren
        initGameField();
        render();
    </script>
</body>
</html>

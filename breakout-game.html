<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dual Ball Breakout</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        
        #gameCanvas {
            border: 2px solid #333;
            background-color: #ddd;
            margin: 20px 0;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        #startBtn {
            background-color: #4CAF50;
            color: white;
        }
        
        #startBtn:hover {
            background-color: #45a049;
        }
        
        #pauseBtn {
            background-color: #ff9800;
            color: white;
        }
        
        #pauseBtn:hover {
            background-color: #e68900;
        }
        
        #resetBtn {
            background-color: #f44336;
            color: white;
        }
        
        #resetBtn:hover {
            background-color: #da190b;
        }
        
        .score {
            display: flex;
            gap: 40px;
            font-size: 18px;
            font-weight: bold;
        }
        
        .score-item {
            text-align: center;
        }
        
        .light-score {
            color: #333;
        }
          .dark-score {
            color: #666;
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            font-size: 16px;
        }
        
        .speed-slider {
            width: 200px;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            cursor: pointer;
        }
        
        .speed-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }
          .speed-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            border: none;
        }
        
        .color-controls {
            display: flex;
            gap: 30px;
            margin-top: 20px;
            align-items: center;
        }
        
        .color-control {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 16px;
        }
        
        .color-picker {
            width: 50px;
            height: 30px;
            border: 2px solid #333;
            border-radius: 5px;
            cursor: pointer;
            padding: 0;
            outline: none;
        }
          .color-picker:hover {
            border-color: #4CAF50;
        }
        
        .auto-color-btn {
            background-color: #9C27B0;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .auto-color-btn:hover {
            background-color: #7B1FA2;
            transform: translateY(-1px);
        }
        
        .auto-color-btn.active {
            background-color: #E91E63;
            box-shadow: 0 0 10px rgba(233, 30, 99, 0.5);
        }
        
        .auto-color-btn.active:hover {
            background-color: #C2185B;
        }
    </style>
</head>
<body>
    <h1>Dual Ball Breakout</h1>
    
    <div class="controls">
        <button id="startBtn">Spiel starten</button>
        <button id="pauseBtn">Pause</button>
        <button id="resetBtn">Reset</button>
    </div>
    
    <canvas id="gameCanvas" width="1024" height="1024"></canvas>      <div class="score">
        <div class="score-item light-score">
            <div>Helle Felder</div>
            <div id="lightFields">512</div>
        </div>
        <div class="score-item dark-score">
            <div>Dunkle Felder</div>
            <div id="darkFields">512</div>
        </div>
    </div>    <div class="speed-control">
        <label for="speedSlider">Spielgeschwindigkeit:</label>
        <input type="range" id="speedSlider" class="speed-slider" min="0.25" max="10" step="0.25" value="2">
        <span id="speedValue">1.0x</span>
    </div>    <div class="color-controls">
        <div class="color-control">
            <label for="lightColorPicker">Helle Felder:</label>
            <input type="color" id="lightColorPicker" class="color-picker" value="#ffffff">
        </div>
        <div class="color-control">
            <label for="darkColorPicker">Dunkle Felder:</label>
            <input type="color" id="darkColorPicker" class="color-picker" value="#000000">
        </div>        <div class="color-control">
            <button id="autoColorBtn" class="auto-color-btn">Automatische Farben</button>
        </div>
        <div class="color-control">
            <button id="colorModeBtn" class="auto-color-btn">Standard</button>
        </div>
        <div class="color-control">
            <label for="colorSpeedSlider">Animation:</label>
            <input type="range" id="colorSpeedSlider" class="speed-slider" min="0.1" max="3" step="0.1" value="1" style="width: 100px;">
            <span id="colorSpeedValue">1.0x</span>
        </div>
    </div>

    <script>
        // Canvas und Kontext
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
          // Spielkonstanten
        const CANVAS_WIDTH = 1024;
        const CANVAS_HEIGHT = 1024;
        const FIELD_SIZE = 32; // 16x16 Pixel pro Feld
        const FIELDS_X = 32; // 32 Felder horizontal
        const FIELDS_Y = 32; // 32 Felder vertikal
        const BALL_RADIUS = 6;
        const BALL_SPEED = 2;          // Spielzustand
        let gameRunning = false;
        let animationId = null;
        let gameSpeed = 2.0; // Geschwindigkeitsmultiplikator
        let lastFrameTime = 0; // Für FPS-Kontrolle
          // Audio Context für Soundeffekte
        let audioContext = null;
          // Feldfarben
        let lightFieldColor = '#ffffff';
        let darkFieldColor = '#000000';
          // Automatische Farbwechsel
        let autoColorMode = false;
        let colorAnimationTime = 0;
        let colorAnimationMode = 0; // 0: Standard, 1: Wellen, 2: Puls, 3: Regenbogen, 4: Kontrast
        let colorAnimationSpeed = 1.0;
          // Partikeleffekte
        let particles = [];
        
        // Spielfeld - 0 = helles Feld, 1 = dunkles Feld
        let gameField = [];
        
        // Animierte Felder für Dreheffekt
        let animatedFields = [];        // Bälle
        let lightBall = {
            x: CANVAS_WIDTH * 0.75, // Startet auf der dunklen Seite
            y: CANVAS_HEIGHT / 2,
            dx: -BALL_SPEED,
            dy: BALL_SPEED,
            type: 'light', // Identifikation über Typ statt Farbe
            trail: [] // Schweif-Positionen
        };
        
        let darkBall = {
            x: CANVAS_WIDTH * 0.25, // Startet auf der hellen Seite
            y: CANVAS_HEIGHT / 2,
            dx: BALL_SPEED,
            dy: -BALL_SPEED,
            type: 'dark', // Identifikation über Typ statt Farbe
            trail: [] // Schweif-Positionen
        };
        
        // Audio Context initialisieren
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        
        // Soundeffekt abspielen
        function playConversionSound(isLightBall) {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Verschiedene Töne für helle und dunkle Bälle
            if (isLightBall) {
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
            } else {
                oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.1);
            }
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
              oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        // HSL zu Hex konvertieren
        function hslToHex(h, s, l) {
            l /= 100;
            const a = s * Math.min(l, 1 - l) / 100;
            const f = n => {
                const k = (n + h / 30) % 12;
                const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0');
            };
            return `#${f(0)}${f(8)}${f(4)}`;
        }
          // Automatische Farben updaten
        function updateAutoColors() {
            if (!autoColorMode) return;
            
            // Zeit für Farbanimation erhöhen
            colorAnimationTime += 0.8 * colorAnimationSpeed;
            
            let lightHue, darkHue, lightSaturation, lightLightness, darkSaturation, darkLightness;
            
            switch (colorAnimationMode) {
                case 0: // Standard - sanfte Rotation
                    lightHue = (colorAnimationTime * 0.5) % 360;
                    darkHue = (lightHue + 180) % 360;
                    lightSaturation = 80;
                    lightLightness = 75;
                    darkSaturation = 90;
                    darkLightness = 25;
                    break;
                    
                case 1: // Wellen - oszillierende Sättigung
                    lightHue = (colorAnimationTime * 0.3) % 360;
                    darkHue = (lightHue + 120) % 360; // Nicht komplementär für mehr Vielfalt
                    lightSaturation = 50 + Math.sin(colorAnimationTime * 0.1) * 40;
                    lightLightness = 60 + Math.cos(colorAnimationTime * 0.15) * 20;
                    darkSaturation = 70 + Math.cos(colorAnimationTime * 0.12) * 25;
                    darkLightness = 30 + Math.sin(colorAnimationTime * 0.08) * 15;
                    break;
                    
                case 2: // Puls - rhythmische Intensität
                    const pulse = Math.sin(colorAnimationTime * 0.2);
                    const fastPulse = Math.sin(colorAnimationTime * 0.8);
                    lightHue = (colorAnimationTime * 0.4 + pulse * 30) % 360;
                    darkHue = (lightHue + 90 + fastPulse * 60) % 360;
                    lightSaturation = 60 + Math.abs(pulse) * 35;
                    lightLightness = 50 + Math.abs(fastPulse) * 30;
                    darkSaturation = 80 + Math.abs(pulse) * 20;
                    darkLightness = 20 + Math.abs(fastPulse) * 25;
                    break;
                    
                case 3: // Regenbogen - schnelle Farbwechsel
                    lightHue = (colorAnimationTime * 1.5) % 360;
                    darkHue = (colorAnimationTime * 1.2 + 240) % 360;
                    lightSaturation = 90 + Math.sin(colorAnimationTime * 0.3) * 10;
                    lightLightness = 70 + Math.cos(colorAnimationTime * 0.4) * 15;
                    darkSaturation = 95;
                    darkLightness = 30 + Math.sin(colorAnimationTime * 0.25) * 10;
                    break;
                    
                case 4: // Kontrast - extreme Gegensätze
                    const contrast = Math.sin(colorAnimationTime * 0.15);
                    lightHue = contrast > 0 ? 45 + contrast * 60 : 200 + Math.abs(contrast) * 80;
                    darkHue = contrast > 0 ? 220 + contrast * 40 : 20 + Math.abs(contrast) * 60;
                    lightSaturation = 40 + Math.abs(contrast) * 55;
                    lightLightness = 80 + contrast * 15;
                    darkSaturation = 60 + Math.abs(contrast) * 35;
                    darkLightness = 15 + Math.abs(contrast) * 20;
                    break;
            }
            
            // Neue Farben generieren
            lightFieldColor = hslToHex(lightHue, lightSaturation, lightLightness);
            darkFieldColor = hslToHex(darkHue, darkSaturation, darkLightness);
            
            // Color Picker aktualisieren
            document.getElementById('lightColorPicker').value = lightFieldColor;
            document.getElementById('darkColorPicker').value = darkFieldColor;
        }// Partikel für Feldumwandlung erstellen
        function createConversionParticles(x, y, fromColor, toColor) {
            const centerX = x * FIELD_SIZE + FIELD_SIZE / 2;
            const centerY = y * FIELD_SIZE + FIELD_SIZE / 2;
            
            // 12 Partikel pro Umwandlung (mehr für besseren Effekt)
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const speed = 1.5 + Math.random() * 4; // Variablere Geschwindigkeit
                const maxLife = 60 + Math.random() * 40; // Längere Lebensdauer (2-3x länger)
                
                particles.push({
                    x: centerX + (Math.random() - 0.5) * 8, // Leichte Startposition-Variation
                    y: centerY + (Math.random() - 0.5) * 8,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: maxLife,
                    maxLife: maxLife,
                    fromColor: fromColor,
                    toColor: toColor,
                    size: 3 + Math.random() * 4, // Größere Partikel
                    initialSize: 3 + Math.random() * 4, // Ursprungsgröße speichern
                    decay: 0.97 + Math.random() * 0.02 // Geschwindigkeitsabnahme
                });
            }
        }
          // Animierte Feldumwandlung erstellen
        function createFieldAnimation(x, y, fromColor, toColor) {
            // Bestehende Animation für dieses Feld entfernen
            animatedFields = animatedFields.filter(field => !(field.x === x && field.y === y));
            
            // Neue Animation hinzufügen
            animatedFields.push({
                x: x,
                y: y,
                fromColor: fromColor,
                toColor: toColor,
                rotation: 0,
                maxRotation: Math.PI, // 180 Grad Drehung
                duration: 40, // 40 Frames = 0.67 Sekunden bei 60fps (etwas länger für besseren Effekt)
                currentFrame: 0
            });
        }        // Partikel updaten und zeichnen
        function updateAndDrawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                // Partikel bewegen (mit Geschwindigkeitsmultiplikator)
                particle.x += particle.vx * gameSpeed;
                particle.y += particle.vy * gameSpeed;
                particle.life -= gameSpeed;
                
                // Geschwindigkeit langsam reduzieren für natürlicheren Effekt
                particle.vx *= particle.decay;
                particle.vy *= particle.decay;
                
                // Partikel entfernen wenn abgelaufen
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                    continue;
                }
                
                // Partikel zeichnen mit Farbübergang
                const progress = 1 - (particle.life / particle.maxLife);
                const alpha = Math.max(0, 1 - progress * 0.7); // Langsameres Ausblenden
                
                ctx.save();
                ctx.globalAlpha = alpha;
                
                // Farbübergang von alter zu neuer Farbe
                if (particle.fromColor === 0) {
                    // Von heller zu dunkler Farbe
                    const r1 = parseInt(lightFieldColor.slice(1, 3), 16);
                    const g1 = parseInt(lightFieldColor.slice(3, 5), 16);
                    const b1 = parseInt(lightFieldColor.slice(5, 7), 16);
                    const r2 = parseInt(darkFieldColor.slice(1, 3), 16);
                    const g2 = parseInt(darkFieldColor.slice(3, 5), 16);
                    const b2 = parseInt(darkFieldColor.slice(5, 7), 16);
                    
                    const r = Math.floor(r1 + (r2 - r1) * progress);
                    const g = Math.floor(g1 + (g2 - g1) * progress);
                    const b = Math.floor(b1 + (b2 - b1) * progress);
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                } else {
                    // Von dunkler zu heller Farbe
                    const r1 = parseInt(darkFieldColor.slice(1, 3), 16);
                    const g1 = parseInt(darkFieldColor.slice(3, 5), 16);
                    const b1 = parseInt(darkFieldColor.slice(5, 7), 16);
                    const r2 = parseInt(lightFieldColor.slice(1, 3), 16);
                    const g2 = parseInt(lightFieldColor.slice(3, 5), 16);
                    const b2 = parseInt(lightFieldColor.slice(5, 7), 16);
                    
                    const r = Math.floor(r1 + (r2 - r1) * progress);
                    const g = Math.floor(g1 + (g2 - g1) * progress);
                    const b = Math.floor(b1 + (b2 - b1) * progress);
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                }
                
                // Größe über Zeit ändern (erst größer, dann kleiner)
                let currentSize;
                if (progress < 0.3) {
                    // Erste 30%: Partikel wird größer
                    currentSize = particle.initialSize * (1 + progress * 0.8);
                } else {
                    // Restliche 70%: Partikel wird kleiner
                    const shrinkProgress = (progress - 0.3) / 0.7;
                    currentSize = particle.initialSize * (1.24 - shrinkProgress * 0.9);
                }
                
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, currentSize * alpha, 0, 2 * Math.PI);
                ctx.fill();
                
                // Zusätzlicher Glow-Effekt für mehr Auffälligkeit
                if (progress < 0.5) {
                    ctx.globalAlpha = alpha * 0.3;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, currentSize * 2, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
          // Animierte Felder updaten und zeichnen
        function updateAndDrawAnimatedFields() {
            for (let i = animatedFields.length - 1; i >= 0; i--) {
                const field = animatedFields[i];
                
                // Animation updaten (mit Geschwindigkeitsmultiplikator)
                field.currentFrame += gameSpeed;
                const progress = field.currentFrame / field.duration;
                field.rotation = progress * field.maxRotation;
                
                // Animation entfernen wenn fertig
                if (field.currentFrame >= field.duration) {
                    animatedFields.splice(i, 1);
                    continue;
                }
                
                // Feld mit Dreheffekt zeichnen
                drawRotatingField(field, progress);
            }
        }        // Rotierendes Feld zeichnen
        function drawRotatingField(field, progress) {
            const fieldX = field.x * FIELD_SIZE;
            const fieldY = field.y * FIELD_SIZE;
            const centerX = fieldX + FIELD_SIZE / 2;
            const centerY = fieldY + FIELD_SIZE / 2;
            
            ctx.save();
            ctx.translate(centerX, centerY);
            
            // Vertikale Drehung um die horizontale Achse (X-Achse)
            // Skalierung der Y-Achse für 3D-Flip-Effekt von unten nach oben
            const scaleY = Math.cos(progress * Math.PI);
            
            // Nur zeichnen wenn das Feld tatsächlich sichtbar ist (nicht komplett seitlich)
            if (Math.abs(scaleY) > 0.02) {
                // Während der ersten Hälfte der Animation zeigen wir die alte Farbe
                // Während der zweiten Hälfte zeigen wir die neue Farbe
                let currentColor;
                if (progress < 0.5) {
                    // Erste Hälfte: Alte Farbe (von unten sichtbar)
                    currentColor = field.fromColor === 0 ? lightFieldColor : darkFieldColor;
                } else {
                    // Zweite Hälfte: Neue Farbe (von oben sichtbar)
                    currentColor = field.toColor === 0 ? lightFieldColor : darkFieldColor;
                }
                
                ctx.scale(1, Math.abs(scaleY));
                
                // Feld zeichnen ohne Hintergrund
                ctx.fillStyle = currentColor;
                ctx.fillRect(-FIELD_SIZE / 2, -FIELD_SIZE / 2, FIELD_SIZE, FIELD_SIZE);
                
                // Zusätzlicher visueller Effekt: Schatten/Gradient für mehr 3D-Gefühl
                if (Math.abs(scaleY) < 0.3) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.fillRect(-FIELD_SIZE / 2, -FIELD_SIZE / 2, FIELD_SIZE, FIELD_SIZE);
                }
            }
            
            ctx.restore();
        }
        function initGameField() {
            gameField = [];
            for (let y = 0; y < FIELDS_Y; y++) {
                gameField[y] = [];
                for (let x = 0; x < FIELDS_X; x++) {
                    // Linke Hälfte = helle Felder (0), rechte Hälfte = dunkle Felder (1)
                    gameField[y][x] = x < FIELDS_X / 2 ? 0 : 1;
                }
            }
            updateFieldCounts();
        }
        
        // Feldanzahl aktualisieren
        function updateFieldCounts() {
            let lightCount = 0;
            let darkCount = 0;
            
            for (let y = 0; y < FIELDS_Y; y++) {
                for (let x = 0; x < FIELDS_X; x++) {
                    if (gameField[y][x] === 0) lightCount++;
                    else darkCount++;
                }
            }
            
            document.getElementById('lightFields').textContent = lightCount;
            document.getElementById('darkFields').textContent = darkCount;
        }
          // Spielfeld zeichnen
        function drawGameField() {
            for (let y = 0; y < FIELDS_Y; y++) {
                for (let x = 0; x < FIELDS_X; x++) {
                    // Überprüfen ob dieses Feld gerade animiert wird
                    const isAnimated = animatedFields.some(field => field.x === x && field.y === y);
                    
                    // Nur statische Felder zeichnen (animierte werden separat gezeichnet)
                    if (!isAnimated) {
                        const fieldX = x * FIELD_SIZE;
                        const fieldY = y * FIELD_SIZE;
                          if (gameField[y][x] === 0) {
                            ctx.fillStyle = lightFieldColor; // Helles Feld
                        } else {
                            ctx.fillStyle = darkFieldColor; // Dunkles Feld
                        }
                        
                        ctx.fillRect(fieldX, fieldY, FIELD_SIZE, FIELD_SIZE);
                    }
                }
            }
        }        // Ball zeichnen
        function drawBall(ball) {
            // Schweif zeichnen
            for (let i = 0; i < ball.trail.length; i++) {
                const pos = ball.trail[i];
                const alpha = (i + 1) / ball.trail.length * 0.8; // Transparenz wird schwächer
                const radius = BALL_RADIUS * alpha; // Radius wird kleiner
                
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
                
                if (ball.type === 'light') {
                    // Heller Ball - verwende helle Feldfarbe
                    const r = parseInt(lightFieldColor.slice(1, 3), 16);
                    const g = parseInt(lightFieldColor.slice(3, 5), 16);
                    const b = parseInt(lightFieldColor.slice(5, 7), 16);
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                } else {
                    // Dunkler Ball - verwende dunkle Feldfarbe
                    const r = parseInt(darkFieldColor.slice(1, 3), 16);
                    const g = parseInt(darkFieldColor.slice(3, 5), 16);
                    const b = parseInt(darkFieldColor.slice(5, 7), 16);
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                }
                
                ctx.fill();
            }
            
            // Ball selbst zeichnen
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, 2 * Math.PI);
            
            if (ball.type === 'light') {
                // Heller Ball - verwende helle Feldfarbe
                ctx.fillStyle = lightFieldColor;
                ctx.strokeStyle = '#333333'; // Dunkler Rand für bessere Sichtbarkeit
            } else {
                // Dunkler Ball - verwende dunkle Feldfarbe
                ctx.fillStyle = darkFieldColor;
                ctx.strokeStyle = '#cccccc'; // Heller Rand für bessere Sichtbarkeit
            }
            
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        // Kollision mit Wänden prüfen
        function checkWallCollision(ball) {
            // Linke und rechte Wand
            if (ball.x - BALL_RADIUS <= 0 || ball.x + BALL_RADIUS >= CANVAS_WIDTH) {
                ball.dx = -ball.dx;
                ball.x = Math.max(BALL_RADIUS, Math.min(CANVAS_WIDTH - BALL_RADIUS, ball.x));
            }
            
            // Obere und untere Wand
            if (ball.y - BALL_RADIUS <= 0 || ball.y + BALL_RADIUS >= CANVAS_HEIGHT) {
                ball.dy = -ball.dy;
                ball.y = Math.max(BALL_RADIUS, Math.min(CANVAS_HEIGHT - BALL_RADIUS, ball.y));
            }
        }        // Kollision mit Feldern prüfen
        function checkFieldCollision(ball) {
            const ballLeft = ball.x - BALL_RADIUS;
            const ballRight = ball.x + BALL_RADIUS;
            const ballTop = ball.y - BALL_RADIUS;
            const ballBottom = ball.y + BALL_RADIUS;
            
            // Betroffene Felder ermitteln
            const leftField = Math.floor(ballLeft / FIELD_SIZE);
            const rightField = Math.floor(ballRight / FIELD_SIZE);
            const topField = Math.floor(ballTop / FIELD_SIZE);
            const bottomField = Math.floor(ballBottom / FIELD_SIZE);
            
            let collisionX = false;
            let collisionY = false;
            
            for (let y = Math.max(0, topField); y <= Math.min(FIELDS_Y - 1, bottomField); y++) {                for (let x = Math.max(0, leftField); x <= Math.min(FIELDS_X - 1, rightField); x++) {
                    const fieldType = gameField[y][x];
                    const ballIsLight = ball.type === 'light';
                    
                    // Kollisionsrichtung bestimmen
                    const fieldCenterX = x * FIELD_SIZE + FIELD_SIZE / 2;
                    const fieldCenterY = y * FIELD_SIZE + FIELD_SIZE / 2;
                    
                    const deltaX = ball.x - fieldCenterX;
                    const deltaY = ball.y - fieldCenterY;                    // RICHTIGE LOGIK:
                    // Heller Ball (light): wandelt helle Felder (0) in dunkle um, kann über dunkle Felder (1) fahren
                    // Dunkler Ball (dark): wandelt dunkle Felder (1) in helle um, kann über helle Felder (0) fahren
                    
                    if (ballIsLight) {
                        // Heller Ball
                        if (fieldType === 0) {
                            // Helles Feld umwandeln
                            gameField[y][x] = 1;
                            
                            // Effekte hinzufügen
                            playConversionSound(true);
                            createConversionParticles(x, y, 0, 1);
                            createFieldAnimation(x, y, 0, 1);
                            
                            // Ball prallt ab
                            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                                collisionX = true;
                            } else {
                                collisionY = true;
                            }
                        }
                        // Bei dunklen Feldern (fieldType === 1) passiert nichts - Ball kann darüber fahren
                    } else {
                        // Dunkler Ball
                        if (fieldType === 1) {
                            // Dunkles Feld umwandeln
                            gameField[y][x] = 0;
                            
                            // Effekte hinzufügen
                            playConversionSound(false);
                            createConversionParticles(x, y, 1, 0);
                            createFieldAnimation(x, y, 1, 0);
                            
                            // Ball prallt ab
                            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                                collisionX = true;
                            } else {
                                collisionY = true;
                            }
                        }
                        // Bei hellen Feldern (fieldType === 0) passiert nichts - Ball kann darüber fahren
                    }
                }
            }
            
            // Ballrichtung ändern bei Kollision
            if (collisionX) ball.dx = -ball.dx;
            if (collisionY) ball.dy = -ball.dy;
            
            return collisionX || collisionY;
        }        // Ball bewegen
        function moveBall(ball, speedMultiplier = 1.0) {
            // Aktuelle Position zum Schweif hinzufügen
            ball.trail.push({x: ball.x, y: ball.y});
            
            // Schweif auf maximale Länge begrenzen
            const maxTrailLength = 16;
            if (ball.trail.length > maxTrailLength) {
                ball.trail.shift(); // Älteste Position entfernen
            }
            
            // Bewegung mit Geschwindigkeitsmultiplikator
            ball.x += ball.dx * speedMultiplier;
            ball.y += ball.dy * speedMultiplier;
            
            // Kollisionen prüfen
            checkWallCollision(ball);
            if (checkFieldCollision(ball)) {
                updateFieldCounts();
            }
        }// Spiel rendern
        function render() {
            // Canvas leeren
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Spielfeld zeichnen
            drawGameField();
            
            // Animierte Felder zeichnen
            updateAndDrawAnimatedFields();
            
            // Partikeleffekte zeichnen
            updateAndDrawParticles();
            
            // Bälle zeichnen
            drawBall(lightBall);
            drawBall(darkBall);
        }
          // Game Loop
        function gameLoop(currentTime) {
            if (!gameRunning) return;
            
            // Berechne die Zeit seit dem letzten Frame
            const deltaTime = currentTime - lastFrameTime;
            
            // FPS-Kontrolle basierend auf Spielgeschwindigkeit
            // Standard: 60 FPS = 16.67ms pro Frame
            const targetFrameTime = 16.67 / gameSpeed;
              if (deltaTime >= targetFrameTime) {
                // Automatische Farben updaten
                updateAutoColors();
                
                // Bälle bewegen (mit Geschwindigkeitsmultiplikator)
                moveBall(lightBall, gameSpeed);
                moveBall(darkBall, gameSpeed);
                
                // Rendern
                render();
                
                lastFrameTime = currentTime;
            }
            
            // Nächster Frame
            animationId = requestAnimationFrame(gameLoop);
        }          // Spiel starten
        function startGame() {
            initAudio(); // Audio initialisieren
            gameRunning = true;
            lastFrameTime = performance.now(); // Startzeit setzen
            gameLoop(lastFrameTime);
        }
        
        // Spiel pausieren
        function pauseGame() {
            gameRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }
        
        // Spiel zurücksetzen
        function resetGame() {
            pauseGame();            // Spielfeld zurücksetzen
            initGameField();
            
            // Partikel zurücksetzen
            particles = [];
            
            // Animierte Felder zurücksetzen
            animatedFields = [];
              // Bälle zurücksetzen
            lightBall.x = CANVAS_WIDTH * 0.75;
            lightBall.y = CANVAS_HEIGHT / 2;
            lightBall.dx = -BALL_SPEED;
            lightBall.dy = BALL_SPEED;
            lightBall.trail = []; // Schweif zurücksetzen
            
            darkBall.x = CANVAS_WIDTH * 0.25;
            darkBall.y = CANVAS_HEIGHT / 2;
            darkBall.dx = BALL_SPEED;
            darkBall.dy = -BALL_SPEED;
            darkBall.trail = []; // Schweif zurücksetzen
            
            // Rendern
            render();
        }
          // Event Listener
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('pauseBtn').addEventListener('click', pauseGame);
        document.getElementById('resetBtn').addEventListener('click', resetGame);
          // Geschwindigkeitsregler Event Listener
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');
        
        speedSlider.addEventListener('input', function() {
            gameSpeed = parseFloat(this.value);
            speedValue.textContent = gameSpeed.toFixed(2) + 'x';
        });
          // Farbauswähler Event Listener
        const lightColorPicker = document.getElementById('lightColorPicker');
        const darkColorPicker = document.getElementById('darkColorPicker');
        
        lightColorPicker.addEventListener('input', function() {
            lightFieldColor = this.value;
            autoColorMode = false; // Automatik ausschalten bei manueller Farbwahl
            updateAutoColorButton();
        });
          darkColorPicker.addEventListener('input', function() {
            darkFieldColor = this.value;
            autoColorMode = false; // Automatik ausschalten bei manueller Farbwahl
            updateAutoColorButton();
        });
          // Automatische Farben Button Event Listener
        const autoColorBtn = document.getElementById('autoColorBtn');
        
        autoColorBtn.addEventListener('click', function() {
            autoColorMode = !autoColorMode;
            updateAutoColorButton();
        });
        
        // Farbanimations-Modus Button
        const colorModeBtn = document.getElementById('colorModeBtn');
        const colorModes = ['Standard', 'Wellen', 'Puls', 'Regenbogen', 'Kontrast'];
        
        colorModeBtn.addEventListener('click', () => {
            colorAnimationMode = (colorAnimationMode + 1) % colorModes.length;
            colorModeBtn.textContent = colorModes[colorAnimationMode];
            colorAnimationTime = 0; // Animation zurücksetzen für sofortigen Effekt
        });
        
        // Farbanimations-Geschwindigkeit
        const colorSpeedSlider = document.getElementById('colorSpeedSlider');
        const colorSpeedValue = document.getElementById('colorSpeedValue');
        
        colorSpeedSlider.addEventListener('input', (e) => {
            colorAnimationSpeed = parseFloat(e.target.value);
            colorSpeedValue.textContent = colorAnimationSpeed.toFixed(1) + 'x';
        });
        
        function updateAutoColorButton() {
            const btn = document.getElementById('autoColorBtn');
            if (autoColorMode) {
                btn.classList.add('active');
                btn.textContent = 'Auto-Farben: AN';
            } else {
                btn.classList.remove('active');
                btn.textContent = 'Auto-Farben: AUS';
            }
        }
        
        // Spiel initialisieren
        initGameField();
        render();
    </script>
</body>
</html>
